### Q1) reflow와 repaint의 차이?

[**reflow와 repaint의 차이점에 대해서 설명해주세요.**](https://www.notion.so/reflow-repaint-18284330e99380228c17ef42c1bc779a?pvs=21) 

### Q2) 자식노드 vs 자식 요소 노드(children vs childNodes)

- 자식노드 vs 자식 요소 노드 ?
    
    ### ✅ 차이 요약
    
    | 개념 | 포함 대상 | 예시 |
    | --- | --- | --- |
    | `childNodes` (노드 기준) | **텍스트, 주석, 요소 등 모든 노드 타입** | 텍스트 노드, 주석 노드, `<div>` 등 |
    | `children` 또는 `firstElementChild` (요소 기준) | **요소 노드(Element Node)만** | 오직 `<div>`, `<p>` 등 태그만 |
    
    ---
    
    ### 🔍 자세한 설명
    
    ### 1. `Node.firstChild`
    
    - **모든 자식 노드 중 첫 번째 노드**를 반환해요.
    - 이때 **텍스트 노드(공백 포함)**나 **주석 노드**도 포함돼요.
    
    ```html
    <div id="parent">
      Text
      <p>Hello</p>
    </div>
    ```
    
    ```jsx
    const parent = document.getElementById("parent");
    console.log(parent.firstChild);  // → #text (공백 포함 텍스트 노드)
    
    ```
    
    ### 2. `Element.firstElementChild`
    
    - **요소 노드만 걸러서** 첫 번째 요소 자식을 반환해요.
    - 텍스트/주석은 무시되고, 오직 `<p>`, `<div>` 같은 태그만 봄.
    
    ```jsx
    console.log(parent.firstElementChild);  // → <p>Hello</p>
    ```
    
    ---
    
    ### 💡 정리하면
    
    - `firstChild`는 **공백도 노드로 취급**함 → 예상치 못한 결과가 나올 수 있음
    - `firstElementChild`는 **진짜 HTML 태그만 반환** → 실무에서 더 많이 사용
    
    ### ✅ 핵심 차이
    
    | 속성 | 포함 대상 | 반환 타입 | 공백 텍스트 노드 포함 여부 |
    | --- | --- | --- | --- |
    | `childNodes` | **모든 자식 노드** (텍스트, 주석, 요소 등) | `NodeList` | ✅ 포함함 |
    | `children` | **요소 노드만** (`<div>`, `<p>` 등) | `HTMLCollection` | ❌ 포함 안 함 |

### Q3) `firstChild` vs `firstElementChild`

```html
<div id="container">
  Hello
  <p>World</p>
</div>

<script>
  const el = document.getElementById("container");
  console.log("1:", el.firstChild.nodeName);
  console.log("2:", el.firstElementChild.nodeName);
</script>
```

### 🔍 예측 출력:

```
1: #text
2: P
```

### ✅ 해설:

- `firstChild`는 텍스트 노드도 포함되므로 `Hello` 앞의 공백이 `#text`로 잡힘
- `firstElementChild`는 요소 노드만 보기 때문에 `<p>` 태그 반환

### Q4) forEach와 DOM 변경 착시

```html
<ul id="menu">
  <li class="item">Home</li>
  <li class="item">About</li>
</ul>

<script>
  const items = document.querySelectorAll(".item");

  document.getElementById("menu").insertAdjacentHTML("beforeend", `
    <li class="item">Contact</li>
  `);

  items.forEach((el, idx) => {
    console.log(`${idx}: ${el.textContent}`);
  });

  const reselect = document.querySelectorAll(".item");
  reselect.forEach((el, idx) => {
    console.log(`(reselect) ${idx}: ${el.textContent}`);
  });
</script>
```

---

### ❓ 예상 출력은?

1. `items.forEach()`에서 Contact도 나올까?
2. 왜 그런 결과가 나왔을까?

---

### ✅ 정답 및 해설

### 🔢 출력:

```
0: Home
1: About
(reselect) 0: Home
(reselect) 1: About
(reselect) 2: Contact

```

### ✅ 핵심 포인트:

- `querySelectorAll()`은 **NodeList (정적)** → **처음 선택된 `items`는 DOM 변경 후에도 변하지 않음**
- 즉, `insertAdjacentHTML()`로 `<li class="item">Contact</li>`을 추가해도, `items`는 여전히 **2개뿐**
- 반면, **DOM 변경 후 새로 선택한 `reselect`*는 Contact까지 포함한 최신 상태

---

### 🔥 개념 확인 정리

| 개념 | 정적(NodeList) | 동적(HTMLCollection) |
| --- | --- | --- |
| `querySelectorAll` | ❌ 실시간 반영 안 함 | - |
| `getElementsByClassName` | - | ✅ 실시간 반영 (Live) |

---

### 💡 실제 실수 포인트

초보자들이 흔히:

- "DOM을 바꿨는데 왜 forEach에서 새로 추가된 요소가 안 나와요?" 라고 착각함
- 원인은 정적 NodeList를 "그 후에도 계속 최신 상태로 반영될 거라" 착각하는 것
- ✅ 그럼 실무에서는 어떻게?
    1. **DOM 변경 후 다시 선택하거나**
    2. 변경된 요소를 **직접 추가해도 괜찮음**
    
    ```jsx
    // 실시간으로 특정 요소만 조작
    const newLi = document.createElement("li");
    newLi.className = "item";
    newLi.textContent = "Contact";
    document.getElementById("menu").appendChild(newLi);
    
    // 추가된 요소만 조작
    console.log(newLi.textContent); // Contact
    ```
    
    ### 🔁 혹은 Live 객체를 써야 할 때는?
    
    ```jsx
    // HTMLCollection (Live 객체)
    const liveItems = document.getElementsByClassName("item");
    
    document.getElementById("menu").appendChild(document.createElement("li")).textContent = "Contact";
    
    console.log(liveItems.length); // ✅ 3 출력됨 (자동 반영)
    
    ```
    
    > 단, HTMLCollection은 forEach가 안 되므로 보통 Array.from()으로 변환해서 사용하는 게 좋아요.
    > 
    
    ### 🔑 결론 정리
    
    > querySelectorAll로 받은 NodeList는 정적이다.
    > 
    > 
    > → **DOM 변경 후에는 반드시 다시 선택하거나**,
    > 
    > → **Live 객체를 사용할 때는 배열로 변환해서 안전하게 다뤄야 한다.**
    >
