### 💡흥미로웠거나 새로 알게된 사실

[{}와 []는 왜 truthy한 값인지](https://www.notion.so/09-19284330e99380d1bb63d0c5903f22e1?pvs=21)

[! 와 !! 의 차이점](https://www.notion.so/09-19284330e99380d1bb63d0c5903f22e1?pvs=21)

[??와 || 을 이용하여 변수 기본값 설정하는 것의 차이점](https://www.notion.so/09-19284330e99380d1bb63d0c5903f22e1?pvs=21)

---

## 9.1 타입 변환이란?

- 명시적 타입 변환(= 타입 캐스팅)
    - 개발자가 의도하는 것
    - 단, 주의할점. 타입캐스팅을 하더라도 **원본은 유지**됨
        
        → 새로운 것을 만들어서 넣는다에 가까움, **재할당 개념이 아님**
        
        ```jsx
        var x = 10;
        var str = x.toString();
        console.log(typeof str); // string
        console.log(typeof x); // number
        ```
        
- 암묵적 타입 변환(=타입 강제 변환)
    - JS 엔진이 암묵적으로 실행시키는 것, 개발자의 의지가 나타나지 않음
    - 대표적인 예시 : 문자열 연산 , `+ ‘’` 이용
    - 명시적 타입 변환과 마찬가지로, 원본이 변경되는 것은 아님. 재할당 개념 XXX
        
        ```jsx
        var x = 10;
        var str = x + '';
        console.log(typeof str); // string
        console.log(typeof x); // number
        ```
        
- 암묵적 타입 변환이 가독성 측면에서 더 좋을수도 있음.
- 하지만 중요한건 **예측가능한 코드**여야 한다는 것. 동료의 코드나 내 코드나.. 타입 변환이 어떻게 동작하는지 정확히 이해하고 사용해야함

## 9.2 암묵적 타입 변환

### 9.2.1 문자열 타입으로 변환

피연산자 중 **하나 이상이 문자열**이면? 문자열 연결 연산자로 동작함.

연산자 예시 : **`+ ‘’`**

```jsx
true + '' // "true"
```

문자열 타입이 아닌 값을 문자열 타입으로 암묵적 타입변환 시켜버린다.

- 헷갈리는 것
    
    ```jsx
    [10, 20] + '' // "10,20" -> 배열 안의 알맹이만 취하는 느낌
    [] + '' // ""
    ```
- 내용물이 있는 객체에 `+ ‘’` 연산을 사용하는 경우
    
    ```jsx
    { a : 1 } + '' 
    ```
    
    객체를 문자열로 암묵적 타입변환.
    
    `+ ''` 연산을 만나면, 객체는 기본적으로 toString()메서드가 호출되고, 이때 [object Object]로 반환됨.
    
    단, 커스텀 객체의 경우?
    
    객체에 `toString()` 또는 `valueOf()` 를 직접 오버라이딩하면 원하는 변환이 가능함!
    
    ```jsx
    const obj = {
      toString() {
        return "Hello!";
      }
    };
    console.log(obj + '');  // "Hello!"
    ```   

### 9.2.2 숫자 타입으로 변환

- 산술연산자(- * /) , 비교 연산자 → 암묵적 타입 변환
    
    ```jsx
    1 - '1' // 0 -> 숫자가 아닌 타입을 숫자처럼 만듦. 암묵적 타입 변환
    '1' > 0 // true
    ```
    
- 숫자 타입으로 변환될 수 없는 타입인 경우 `NaN` 으로 대체됨.
    
    ex) 1 / ‘string’  //  `NaN`
    
- + 단항 연산자 헷갈리는 것
    
    ```jsx
    // 변환되지 않으므로 NaN 출력
    +undefined
    +{}
    +[10,20]
    
    // 나머지 '',[],null,false는 0이 됨
    ```
    
- 이렇게 연산과정중에 암묵적으로 false값으로  평가되는 값 → Falsy 값!!
    - 조건문과 같이 boolean값으로 평가되는 과정에서 falsy값은 false로 암묵적 타입 변환이 일어남.
    - falsy값 종류
        - false, undefined, null, 0, -0, NaN, ‘’(빈문자열)
- 헷갈리는점 :  {} 랑 []는 왜 truthy한 값인가?
객체와 배열은 **메모리에 존재하는 참조형 데이터**라서, `null`이 아닌 한 유효한 값으로 간주됨.
**객체가 비었는지 체크하려면 직접 길이를 확인**해야 함.

## 9.3 명시적 타입 변환

### 9.3.1 명시적 (문자열) 타입 변환

- 개발자의 의도에 따라 진행
- 다양한 방법으로 명시적 타입변환 가능.
    1. **new 연산자 없이** (표준 빌트인)**생성자** 함수 사용
    2. 빌트인 메서드( Object.prototype.**toString 메서드**) 사용
    3. 압묵적 타입 변환 이용 → 문자열 연결 연산자 `+ ''`

### 9.3.2 숫자 타입으로 변환

1. Number 생성자 함수, new 연산자 없이.
2. parseInt, parseFloat 함수(단, 문자열만 적용 가능한 방법임.)
3. + 단항 산술 연산자 이용 (가장 앞에 + 가 붙는 것)
4. * 산술연산자 이용
- 궁금한 점. - 는 왜 숫자 타입으로 변환되지 않는가?
    
    `-` (단항 마이너스 연산자)도 사실 숫자 타입으로 변환되지만, `-`의 주요 목적은 변환보다는 **부호를 바꾸는 것**이므로, `Number()` 변환을 위한 방법으로 잘 언급되지 않는 것일 뿐이다.
    

### 9.3.3 불리언 타입으로 변환

1. Boolean 생성자 함수, new 연산자 없이.
2. ! 부정 논리 연산자를 두 번 사용하기
    
    `!!value`는 **`Boolean(value)`**와 같은 효과
    
    ✅ `!` vs `!!` 차이점
    
    `!!value`는 **`Boolean(value)`와 같은 효과**를 가짐.
    
    `!` (부정 연산자)
    
    - 값을 **불리언(Boolean)으로 변환한 후 반전**시킴.
    - 즉, truthy한 값은 `false`, falsy한 값은 `true`가 됨.
    
     `!!` (이중 부정)
    
    - 첫 번째 `!`로 값이 불리언으로 변환된 후 반전됨.
    - 두 번째 `!`로 다시 반전되어 **원래 값의 truthy/falsy 상태를 유지한 불리언 값으로 변환**됨.
    - 결과적으로 **`Boolean(value)`와 동일한 역할**을 함.
    
    ---
    
    ✅ `!!`를 사용하는 이유
    
    - 값을 **명확하게 `true` 또는 `false`로 변환**할 때
    - **조건문에서 truthy/falsy 여부를 확인**할 때

## 9.4 단축평가

- 논리곱 연산자(&&)와 논리합 연산자(||)가 등장한다면…. 고려해보기!
- 논리 연산의 결과를 결정하는 피연산자를, 타입 변환 없이 그대로 반환하는 것.
- 표현식을 평가하는 도중 결과가 확정됐을 때 나머지 평가 과정을 생략하는것
- 좌항에서 우항으로 평가가 진행되는 원리 기반
- A && B에서 첫번째 값(A)이 true하다면, 두 번째 피연산자(B)를 그대로 반환함.
    
    Why? 둘다 true한 값이어야 결과가 참이 되므로, 결과는 두 번째 피연산자인 B에게 달렸기 때문으로 파악함.
    
- 비슷한 논리로, A || B 에서 첫번째 값이 false하다면 두번째 피연산자(B)를 그대로 반환함.

![image](https://github.com/user-attachments/assets/052446ae-c552-451e-9b7d-39b5375d2b27)


단축 평가의 장점, 유용한 점

- 단축평가로 if문 대체도 가능
    
    조건이 true값일때 무언갈 해야한다면 → && 사용
    
    조건이 false값일때 무언갈 해야한다면 → || 사용
    
    ‘무언가’ 가 두 번째 피연산자 자리에 옴
    
    ex) message = done && ‘완료’ //  done이 true라면, 두번째  피연산자인 ‘완료’가 message에 저장됨
    
- `&&` : 타입 에러 예방 가능.
    - null 또는 undefined를 참조하게 되는 상황에서, 타입 에러가 발생.
    - 이러한 상황을 차단 가능
    
    ```jsx
    var elem = null;
    var value = elem && elem.value; // elem이 false값으로 평가되므로, 
    // 두 번째 피연산자가 평가되지 않아 타입에러 발생 X 
    ```
    
- `||` 변수 초기값(기본값) 설정 가능
    - undefined 가 저장되는 것 예방 가능
    
    ```jsx
    str = str || ''; // str 가 undefined일때, 기본값 ''(빈 문자열) 로 설정됨
    ```
    

### 9.4.2 옵셔널 체이닝 연산자

- `?.` 을 기준으로, 왼쪽(피연산자)이 null이나 undefined 일 경우 undefined 반환
    
    그게 아니라면 오른쪽 방향으로 참조 이어나감
    
    ```jsx
    var elem = {value:1};
    var value = elem?.value; // 1
    ```
    

주의할점 : 0과 ‘’(빈 문자열)

- 이 둘은 `&&`의 좌항 피연산자 자리에 올때, falsy값으로 평가되므로 0과 ``이 그대로 반환된다.
- 하지만 `?.` 의 좌항 피연산자 자리에 올때는, 객체로 평가된다.
    
    ```jsx
    var str = '';
    var length = str?.length; // 0 -> 객체로 평가되어 빈 값으로 간주됨. undefined가 아님. 
    ```
    

### 9.4.3 null 병합 연산자

- `??` 사용
- 변수에 기본값 설정할때 유용
- 궁금한 점. `||`을 이용하여 변수에 기본값 설정하는 것과 어떤점이 다른가?
    
    `??` 을 이용하는 방법의 경우, 좌항 피연산자에 0이나 ‘’(빈 문자열) 오는 경우도 고려해줄 수 있음
    
    ```jsx
    var foo = '' || 'default'; // 'default'
    var foo2 = '' ?? 'default'; // '' ->''도 빈 문자열으로서 유효한 값으로 인정받음
    ```
    
    대신 좌항 피연산자가 null이나 undefined만 아니면 됨.
