### 💡흥미로웠거나 새로 알게된 사실

[일급 객체의 개념](https://www.notion.so/10-19784330e99380899e12f779ced11df9?pvs=21)

[window.name의 존재](https://www.notion.so/10-19784330e99380899e12f779ced11df9?pvs=21)

[존재하지 않는 프로퍼티와 존재하지 않는 변수에 접근할때의 차이](https://www.notion.so/10-19784330e99380899e12f779ced11df9?pvs=21)

---

## 10.1 객체란?

- 자바스크립트는 객체 기반, 구성하는 거의 모든 것이 객체임(원시값 제외)
- 객체 특징
    - 다양한 타입의 값을 담고 있는 덩어리, 복합적인 자료구조
    - 객체는 변경 가능한 값
- 객체의 구성요소
    - 0개 이상의 **프로퍼티**로 구성, 프로퍼티는 key-value 형태
    - **메서드** : 프로퍼티 값이 함수인 case
- 프로퍼티
    - js에서 사용하는 **모든 값** 가능
    - 함수도 가능. → 일반 함수와 구분하려고 ‘메서드’라고 부름
        - Why? 함수를 값처럼 다룰 수 있는 이유?  js에서 함수는 **일급 객체**이기 때문.
            
            일급 ? 사용할 때 다른 요소들과 아무런 차별이 없다는 뜻.
            
            <aside>
            ❓
            
            일급 객체의 조건
            
            - 변수나 데이터 구조(객체, 배열 등)에 할당할 수 있다. 담을 수 있다.
                - 생각해 보면 자바의 메소드는 변수에 할당하거나 그럴순 없다.
                - 반면에 자바스크립트는 함수 표현식으로 자유롭게 대입이 가능하다.
            - 함수의 인자(매개변수)로 전달할 수 있다
                - 역시 자바의 메소드를 메소드 입력값으로 보내는 행위는 불가능하다.
                - 반면에 자바스크립트는 콜백 함수(다른 함수의 인자로 전달되어 실행되는 함수**)** 형태로, 자유롭게 전달이 가능하다.
            - 함수의 **반환값**으로 사용할 수 있다
                - 역시 자바의 메소드의 리턴값으로 메소드 자체를 반환 행위는 불가능하다.
                - 반면에 자바스크립트는 클로저(Closure) 기법(함수가 실행된 후에도 외부 함수의 변수를 기억하고 사용할 수 있는 메커니즘)을 통해 구성할 수 있다.
            </aside>
            
        - 예시
            
            ```jsx
            // 1. 변수에 함수 할당
            const sayHello = function() { console.log("Hello!"); };
            
            // 2. 함수의 매개변수로 전달
            function executeFunction(func) {
                func();  // 전달받은 함수를 실행
            }
            executeFunction(sayHello); // "Hello!" 출력
            
            // 3. 함수가 또 다른 함수를 반환
            function createMultiplier(factor) {
                return function(num) {
                    return num * factor;
                };
            }
            const double = createMultiplier(2);
            console.log(double(5)); // 10
            
            ```
            
        
- 객체에서는 이렇게 상태(프로퍼티)와 동작(메서드)를 하나의 단위로 구조화할 수 있어 유용함!

## 10.2 객체 리터럴에 의한 객체 생성

- 다양한 객체 생성 방법 지원 → JS는 프로토타입 기반 객체지향 언어로서, 클래스 기반 객체지향 언어와는 다름
    
    ? 프로토 타입 기반 : 클래스로 객체를 만드는 게 아니라 기존 객체를 복제(참조)해서 새로운 객체를 만드는 방식. 
    
    모든 객체는 숨겨진 링크인 [[Prototype]]을 가지고 있고, 이는 다른 객체를 가리킴. 이렇게 **객체가 다른 객체를 상속받는 방식**을 말함.
    
    최상위 객체 ? Object.prototype
    
- 객체 생성 방법
    - 객체 리터럴 → 비교적 유연한 방식, 유일하게 함수를 사용하지 않는 방법
    - Object 생성자 함수
    - 생성자 함수
    - Object.create 메서드
    - 클래스(ES6)
- 객체 리터럴
    
    ```jsx
    var person = {
      name: 'Lee',
    	sayHetlo: function () {
    		console.log('Hello! My name is ${this.name}.");
    	}
    };
    console.log(typeof person); // object
    console.log(person); // {name: "Lee", sayHello: f}
    ```
    
    - 중괄호 { } 로 프로퍼티 정의
    - 프로퍼티가 없다면? 그냥 빈 객체 생성됨.
    - 하나의 ‘값’으로 평가되는 표현식이기 때문에 끝에 ; 붙여주기
    - 왜 유연한가? 객체를 생성함과 동시에 프로퍼티를 만들 수 있고, 나중에 동적으로 추가도 가능.

## 10.3 프로퍼티

- 프로퍼티끼리는 쉼표(,)로 구분
- key와 value에 활용될 수 있는 값?
    - key : **모든 문자열**(”” 포함) or 심벌 값
        - 근데 key에 문자열이나 심벌값이 아닌 값이 오는 경우?
            
            암묵적 타입 변환을 통해 문자열이 됨(ex-숫자)
            
    - value : JS에서 사용할 수 있는 모든 값
- 프로퍼티 키는 반드시 식별자 네이밍 규칙을 따라야 하는가?
    - No!
    - 대신에 반드시 이름에 따옴표 ‘’ 를 사용해야함
        
        ```jsx
        var person = {
        	firstName: 'A-jin',
        	'last-name': 'Shin'
        }
        ```
        
- 프로퍼티 key 동적으로 생성하기
    - 문자열이나 문자열로 평가(계산)될 수 있는 표현식 → 반드시 대괄호 [ ] 이용해야함
        
        ```jsx
        person["to-do"] = "밥먹기";
        ```
        
    - 대괄호 표기법을 반드시 사용하지 않을 경우에는, 점 표기법 사용하면 됨
        
        ```jsx
        person.age = 25; // 이때 key인 age는 자동으로 문자열로 변환됨
        ```
        
- 주의할 점 : 프로퍼티 key를 객체 리터럴 안에서 중복선언 한다면?
    
    → 나중 프로퍼티가 원래 프로퍼티를 덮어씀. 에러가 발생하는 것이 아님.
    

## 10.4 메서드

- 프로퍼티 값이 함수인 case
- 복습) JS에서 함수는 일급객체이므로 값으로 취급가능, 프로퍼티 값으로도 활용가능

## 10.5 프로퍼티 접근

프로퍼티 접근 방법은 2가지.

1. 마침표 표기법
    
    접근 연산자(.) 사용
    
2. 대괄호 표기법
    
    접근 연산자(…) 사용
    
- 2가지 방법을 어느 경우에 사용해야하는가?
    - 일반적인 객체는 둘 다 상관없음
    - 식별자 네이밍을 준수하지 않는 경우(-가 들어가거나 숫자로 시작하는 등..) → 무조건 대괄호 표기법으로 접근
    
    ```jsx
    var person = {
    	name : 'Shin'
    };
    console.log(person.name); // Shin
    console.log(person['name']); // Shin, 따옴표로 감싸기
    ```
    
    주의할점! 
    
    대괄호표기법에서 key를 적을때, 무조건 따옴표’ ‘로 감싸주기
    
    안감싸주면 하나의 변수(식별자)로 판단해버림 
    
    결국 존재하지 않는 프로퍼티로 판단하고 undefined 출력됨.(유연함 확보)
    
    (존재하지 않는 변수에 접근하면 Reference Error임! 헷갈리지 않기)
    
    - key가 숫자인 경우에는 반드시 대괄호 표기법을 사용하되, 따옴표 ‘ ‘ 생략 가능. ex) person[1] 또는 person[’1’]
- 궁금한 점

    ![image](https://github.com/user-attachments/assets/4915e2a0-52fe-4f2a-b161-d4f633a08c1e)
    ![image (1)](https://github.com/user-attachments/assets/ba431921-a6ae-4532-88b1-6a6ebe79ac76)

    
    브라우저 환경에서 `name`이라는 전역 변수가 암묵적으로 존재한다는 뜻?
    
    브라우저 환경에서는 `window` 객체가 **전역 객체**인데
    
    브라우저에서는 `window.name`을 **윈도우 또는 탭의 이름을 저장하는 용도로 제공.** 기본값은 ‘’(빈 문자열)
    그래서 undefined-’’ 가 되고 → 산술연산자(-)로 인식 → undefined는 숫자가 아니므로 NaN 발생
    

## 10.6 프로퍼티 값 갱신

- key에 이미 있는 value값을 갱신할 수 있음(재할당 가능)
    - 점 표기법, 대괄호 표기법 이용.(생성할때랑 동일)

## 10.7 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값을 할당하는 방식
    
    ```jsx
    var person = {
    	firstName: 'A-jin',
    	'last-name': 'Shin'
    }
    person.age = 25;
    ```
    

## 10.8 프로퍼티 삭제

- `delete` 연산자 활용
- 존재하지 않는 프로퍼티를 삭제한다면 → 그냥 무시됨

```jsx
delete person.age // delete 뒤에는 값이될수있는 녀석(표현식)이 와야함
```

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

- 프로퍼티 값에 값으로 평가될 수 있는 변수(식별자 표현식)도 가능
- 이때 변수 이름와 key가 동일하다면 , key 생략 가능
    
    ```jsx
    let x=1, y=2;
    const obj = {x,y}; // 굳이 x:x, y:y 안해줘도
    ```
    
- 계산된 프로퍼티 이름
    - 대괄호 안에서 key를 적을때, 문자열이 포함된 표현식도 가능
        
        ```jsx
        var prefix = 'prop';
        var i=0;
        obj[prefix+'-'+ ++i] = i; // { prop-1 : 1 }
        ```
        
    - 객체 리터럴 내부에서도 가능(생성과 동시에 선언할 때)
- 메서드 정의할때 `function`  키워드 생략 가능.
    - 궁금한 점 : arrow function ( ()⇒{} 형태 ) 도 메서드 정의에서 쓸 수 있는가?
        
        화살표 함수(arrow function)는 메서드 정의용으로 적절하지 않음.
        
        → 문법적으로는 문제없는데 `this`가 의도대로 동작하지 않을 가능성 있음. 왜냐면 화살표 함수는 this를 가지지 않기 때문. 일반함수에서는 호출한 객체가 this가 되는데, 화살표 함수에서는 상위 스코프에서 this를 가져옴.
        
        `this.name` 으로 접근하는 경우 → 아까와 같은 window.name이 될 수도
        
- 축약 표현으로 정의한 메서드 ≠ 프로퍼티에 할당한 함수 다르게 동작함. → 이유는 26장에..
