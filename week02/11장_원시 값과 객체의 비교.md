### 💡흥미로웠거나 새로 알게된 사실

[원시값이 재할당되는 원리](https://www.notion.so/11-19784330e993800e8f36d8ef1cc4b3df?pvs=21)

[문자열은 원시값인데 객체처럼 동작이 가능한 이유](https://www.notion.so/11-19784330e993800e8f36d8ef1cc4b3df?pvs=21)

---

원시값과 객체의 차이점을 잘 알아두어야 할 듯!

## 11.1 원시값

### 11.1.1 변경 불가능한 값

- 원시 타입을 가지고 있는 원시값은 **변경 불가능한 값**.
    
    여기서, ‘변경 불가능한 값’이란? 원시값 자체를 변경할 수 없다는 의미. 변수 값을 변경할 수 없다는 의미가 아님. 변수는 재할당 언제든지 가능
    
- 변수에 새로운 원시값을 재할당 하면 일어나는 일
    
    ```jsx
    	var score;   // undefined
    	score = 80;  // 80
    ```
    
    1. 새로운 값(80)을 위한 새로운 메모리 공간을 확보한다.
    2. 재할당한 원시 값을 새로운 메모리 공간에 저장한다.
    3. 변수(score)는 새롭게 재할당한 원시값(2.)을 가리킨다.
    
    여기서 핵심은, 기존에 undefined 를 가지고 있던 주소와 같은 주소에 값이 재할당되는 개념이 아니라, 새로운 값을 가진 **새로운 주소로 변수의 참조를 바꾸는 것**임.
    
    → 불변성
  
    ![IMG_0960](https://github.com/user-attachments/assets/fec70a3e-d2f6-4dc5-89e9-57dbc32c2f2a)


- 만약에 변경 가능한 값이었다면?
    ![IMG_0961](https://github.com/user-attachments/assets/fa5caea0-94a2-493f-b79f-342cfc4b9284)
  
    그림 11-2처럼 그냥 기존 주소에 값을 다시 넣으면 된다. → 상태 변경 추적하기 어려움…
    
    하지만 원시값은 **변경 불가능**이기 때문에, 재할당할때는 새로운 주소에 값을 넣고 변수가 그 주소를 가리키게 만들어야 한다.
    

### 11.1.2 문자열과 불변성

- 6.9.1 복습) 원시값을 저장하려면, 타입별로 메모리 공간의 크기가 미리 정해져 있어야 함.
- JS에서 문자열은 원시값임
    - 몇 개의 문자로 이루어졌느냐에 따라, 필요한 메모리 공간의 크기가 유동적으로 결정됨.
    - 원시값이기 때문에 문자열은 **변경 불가능**한 값임.

```jsx
var str = 'Hello';
str = 'world';
```

- 변수에 문자열 재할당도, 위에서 살펴봤던 그림 11-1 처럼 동작함.(새로운 메모리 주소 할당)
- 문자열은 원시값이지만, 동시에 유사 배열 객체이기도 하다.
    
    → 객체는 아니지만 **객체처럼 메서드나 속성을 쓸 수 있다**!
    
- 유사 배열 객체란?
    - 배열처럼 인덱스로 프로퍼티 값에 접근 가능
    - length 프로퍼티 가짐
    - 문자열은 원시값이면서 유사배열 객체
    - 원시값인데 객체처럼 동작이 가능한 이유? 원시 값을 객체처럼 사용하면, 원시값을 감싸는 **래퍼 객체로 자동 변환**되기 때문이다.
- 이미 생성된 문자열의 일부 문자를 변경해도 원본에는 반영되지 않는다. → 자바랑 동일?
    
    ```jsx
    var str = 'string';
    str[0] = 'S'; //  반영되지 않음
    console.log(str);  // string
    ```
    
    - 문자열의 일부를 바꾸고 싶으면 어떻게 해야하는지..?
        
        **문자열을 배열로 변환 후 조작하기 (가장 보편적)**
        
        ```jsx
        var str = 'string';
        var arr = str.split(''); // 문자열을 배열로 변환
        arr[0] = 'S'; // 첫 글자 변경
        str = arr.join(''); // 다시 문자열로 변환
        console.log(str); // "String"
        ```
        
        → `split('')`으로 문자열을 문자 배열로 만들고, 변경 후 `join('')`으로 다시 문자열로 변환
        
    
- 재할당이랑 값 변경을 헷갈리지 말자!
    - 변수에 문자열 재할당 가능
    - 문자열은 원시값이므로, 값 자체는 변경 불가능. 따라서 재할당은 기존 문자열을 변경하는 방식이 아니라새로운 문자열을 새롭게 할당하는 방식으로 이루어짐.

### 11.1.3 값에 의한 전달

- ‘공유에 의한 전달’이라고 표현하기도
- 변수에 원시값을 가진 변수를 할당하면, **원시값이 복사되어 전달**됨.
    
    ```jsx
    var score = 80;
    var copy = score;
    console.log(score, copy); // 80 80
    console.log(score === copy); // true
    ```
    
    copy에는 score변수의 80 이 ‘복사되어’ 저장되는것
    
    → score변수와 copy 변수는 서로 다른 메모리 공간에 저장된 **별개의 값**임.
    
- 또다른 방법 : 메모리 주소를 그대로 전달하는 방식.(like 파이썬)
    - 변수에 원시값을 갖는 변수를 할당하는 시점에는, 두 변수(score,copy)가 동일한 원시값 참조중임
    - 어느 한 쪽의 변수에 재할당이 이루어졌을 때 새로운 메모리 공간에 재할당된 값을 가지고 참조값이 바뀜
- 사실 엄밀하게 따지면, 전달되는 것은 값이 아니라 메모리 주소임.
    
    하지만 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 **저장된 값에 접근할 수 있다**는 의미로, **값이 전달된다**고 하는 것임.
    

## 11.2 객체

- 자바스크립트에서의 객체
    - 클래스 없이 객체 생성 가능
    - 프로퍼티 개수가 정해져 있지 않음 → **동적으로 추가 삭제** 가능
    - 프로퍼티가 가질 수 있는 값이 정해져 있지 않음(모든 값 가능)
    
    하지만 확보해야할 메모리 크기를 원시값처럼 미리 정해둘 수 없음.. → 생성과 프로퍼티 접근에 비효율적임. (동적 추가/삭제 기능이 편리하다는 장점)
    
    (cf) 클래스 기반 객체 지향 언어(C++,Java)는 사전에 프로퍼티와 메서드가 다 정해진 객체 그대로 생성하는 방식)
    
    - v8 자바스크립트 엔진에서는 , 히든 클래스라는 기능으로 클래스와 유사하게 동작하도록 해서 성능 어느정도 향상됨.

### 11.2.1 변경 가능한 값

- 원시값과 다르게 ,**객체는 변경가능한 값**임
- 객체를 할당한 변수가 기억하는 것? 참조 값. 생성된 객체의  실제 메모리 주소.
    
    그래서 변수는 이 참조 값을 통해 실제 객체에 접근할 수 있음.
    

변수 → 객체가 저장된 메모리 주소 → 객체 내용

- 변수는 객체를 참조하고 있다 ( = ) 변수는 객체를 가리키고 있다.

- 변수에서 저장된 객체 값을 변경하기
    - 객체는 원시값처럼 불변한 값이 아닌, 변경 가능한 값
    - 따라서 재할당 과정 없이, 그냥 바로 메모리 주소로 가서 값을 변경해주면 됨
    - 동적 추가 / 갱신 / 삭제 전부 가능
    
    이때, 객체를 할당한 변수의 참조 값은 변경되지 않음. 그 내용이 직접 수정되는 것.
    
- 객체는 왜 변경가능한 값인가?
    - 원시값처럼 변경하지 못해서 재할당 과정을 거쳐야 한다면?
        
        → 객체마다 크기가 다르고, 프로퍼티 값 자체가 또 객체일 수도 있어서 복사해서 생성하는 과정에서 비용 많이 소모됨
        
        → 메모리를 효율적으로 사용하기 위해, 복사 비용을 절약하고 성능을 향상시키기 위해 변경 가능한 값으로 설계되어 있음.
        

- 부작용 → 여러 개의 식별자가 하나의 객체를 공유할 수 있어버림.
    
    ```jsx
    const o = { x:1 };
    const c2 = o;
    console.log(c2 === 0); // true
    ```
    
    - JS에서는, 객체를 할당한 변수를 다른 변수에 할당하는 **얕은 복사**가 일어남.
        
        주소값이 그대로 전달되는 원리 → 같은 주소값을 가지므로 같은 객체를 공유하게 됨
        
        하나에서 수정하면 → 나머지 하나도 영향을 받음. 원치않게 수정됨.
        
    - 반면, 원시값을 할당한 변수를 다른 변수에 할당하는 과정은 깊은 복사임.
        
        완전한 복사본을 만드는 원리. 원본과 복사본은 참조 값이 다른 별개의 값이 됨.
        
    - 객체를 깊은복사하면? 객체에 중첩되어있는 객체까지 모~두 복사됨.(완전한 복사)

- 사실 원시값이나 객체나 변수에 메모리 주소가 저장되는 것 자체는 동일함
- 하지만 그 메모리 공간에 저장되는 값(원시값? 참조값?)이냐가 다름
- 전달되는 값의 종류가 원시 값인지, 참조 값인지 구별하자는 의미로 ‘값에 의한 전달’ / ‘참조에 의한 전달’로 구분하여 부름.(이 책에서만)
    
    

```jsx
var person1 = {
	name : 'Shin'
};
var person2 = {
	name : 'Shin'
};
```

→  **내용물이 아무리 같더라도**, 객체 리터럴은 평가될때마다 객체를 생성하기 때문에 서로 다른 참조 값을 가짐. **다른 객체임.**
