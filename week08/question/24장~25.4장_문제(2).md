### ✅ 문제 1. [this 바인딩 헷갈리기 퀴즈]

```jsx
var name = "Global";

function foo() {
  console.log(this.name);
}

const obj = {
  name: "Object",
  method: foo
};

//obj.method();
setTimeout(obj.method, 0);
```

**Q. 콘솔에 출력되는 값은?**

- A) "Global"
- B) "Object"
- C) undefined
- D) 오류 발생

- 1번 답
    
    **정답: A) "Global"**
    
    **왜?**
    
    setTimeout 안에서 `obj.method`는 **일반 함수처럼 호출되므로 this는 전역 객체**를 바인딩한다.
    
    ### ✅ 우리가 흔히 착각하는 부분:
    
    > “obj.method니까 this는 obj겠지!”
    > 
    
    → ❌ 그런데 **실제로는 그렇지 않아!**
    
    왜냐하면 이 코드는 이렇게 동작하기 때문이야:
    
    ```jsx
    setTimeout(obj.method, 0);
    // -> obj.method가 평가되어 함수 foo가 나오고,
    // -> 그 함수(foo)를 setTimeout이 실행할 뿐이야.
    ```
    
    즉, **함수만 전달하고 있고**, **obj랑은 아무 연결 없이 실행**되기 때문에,
    → **this는 전역 객체(`window` or `global`)가 되어버려!**
    
    **토의 포인트:**
    
    - 왜 `obj.method()`는 this가 obj인데, `setTimeout(obj.method)`는 this가 전역이 되는지?
        
        `obj.method()`는 **즉시 실행되므로**, 그 순간에는 `this === obj` 맞음
        

### ✅ 문제 2. [헷갈리기 마스터급: this + 메서드 vs 일반 함수]

```jsx
const obj = {
  name: "MyObject",
  sayHello: function() {
    console.log(this.name);
  }
};

const another = {
  name: "AnotherObject",
  sayHello: obj.sayHello
};

const temp = obj.sayHello(
temp();              // ❓ 1 -> MyObject
another.sayHello();  // ❓ 2 -> MyObject
obj.sayHello();      // ❓ 3 -> MyObject
```

**Q. 각 줄의 출력 결과는?** 

- 2번 답
    
    **정답:**
    
    1. `""` (일반 함수 호출 → this는 전역)
    2. `"AnotherObject"` (메서드 호출 → this는 another)
    3. `"MyObject"` (메서드 호출 → this는 obj)
    
    **토의 포인트:**
    
    - 함수가 **객체에서 호출되었는지**가 관건.
    - `obj.sayHello`는 함수 참조일 뿐이고, `temp()`처럼 따로 호출되면 this는 obj가 아님!
    - **"함수를 변수에 할당하면 this 바인딩은 날아간다"** → 이걸 확실히 이해해야 함!

### ✅ 문제 3. [call과 bind 혼합 헷갈리기 문제]

```jsx
const obj = {
  name: "OBJ",
  show: function() {
    console.log(this.name);
  }
};

const bound = obj.show.bind({ name: "BOUND" });

bound.call({ name: "CALL" }); // ❓ 출력 결과는
```

**Q. 결과는?**

- A) "OBJ"
- B) "CALL"
- C) "BOUND"
- D) undefined

- 3번 답
    
    **정답: C) "BOUND"**
    
    **왜?**
    
    - `bind()`는 this를 **영구 고정**시킨 함수 반환!
    - `call()`을 나중에 붙여도 의미 없음 → 이미 this는 "BOUND"로 잠겨 있음!
    
    **토의 포인트:**
    
    - `bind`는 함수 자체를 바꾸고,
    - `call`은 단순히 "한 번 실행할 때만" this 바꿔줌.
    - bind로 고정한 this는 절대 다시 바뀌지 않는다!

### ✅ 문제 4. [실행 컨텍스트 스택 순서 꼬기]

```jsx
function first() {
  console.log("first");
  second();
}

function second() {
  console.log("second");
  third();
}

function third() {
  console.log("third");
}

first();
```

**Q. 실행 컨텍스트 스택의 변화 흐름은?**

A) first → second → third → 전역

B) 전역 → first → second → third → second → first → 전역

C) 전역 → first → second → third → second → first

D) 전역 → third → second → first → 전역

- 4번 답
    
    **정답: B) 전역 → first → second → third → 전역**
    
    **왜?**
    
    - JS 프로그램은 **항상 전역 실행 컨텍스트(Global EC)** 부터 시작함.
    - 그다음 `first()` 호출 → first EC 생성
    → 그 안에서 `second()` → second EC → 그 안에서 `third()` → third EC
    - third 실행이 끝나면 **스택에서 제거**, 다시 second → first → 전역만 남음.
    - **모든 함수가 끝나고 나서도** 콜 스택에 `전역 컨텍스트`는 여전히 남아 있는 상태.
    (함수들 다 pop되고 마지막에야 pop됨)
    
    **토의 포인트:**
    
    - 실행 컨텍스트는 **"호출 시점"에 쌓임**
    - 스택은 LIFO 구조 (Last In First Out)

### ✅ 문제 5: [렉시컬 환경 참조 (클로저 없이 설명 가능)]

```jsx
var x = 1;

function inner() {
  console.log(x);
}

function outer() {
  var x = 2;
  inner();
}

outer();
```

**Q. inner 함수는 어떤 x를 출력하는가?**

A) 1

B) 2

C) undefined

D) ReferenceError

- 5번 답
    
    👉 **정답: A) 1**
    
    **왜?**
    
    ### 🧠 핵심 포인트: **"함수가 어디서 정의됐는지가 중요"**
    
    → **함수가 어디서 호출됐는지**가 아니라
    
    → **함수가 정의된 "위치" 기준으로 스코프가 결정**
    
    - inner는 전역에서 선언됨 → **상위 스코프는 전역**
    - outer 함수 안의 x는 inner에겐 **무관**
    - 따라서 inner는 전역 x=1 참조
