<details>
  <summary>예제 코드들</summary>

```javascript
function foo() {
  const x = 1;
  const y = 2;
  function bar() {
    debugger;
    console.log(x);
  }
  return bar;
}
const bar = foo();
bar();
```

<br>

```javascript
function foo() {
  const x = 1;
  const y = 2;
  function bar() {
    const z = 3;
    function car() {
      debugger;
      console.log(x);
      console.log(z);
    }
    return car;
  }
  return bar();
}
const bar = foo();
bar();
```

```javascript
var funcs = [];
for (var i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  };
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```

</details>

### 다음 코드의 결과는?

```javascript
var funcs = [];
for (var i = 0; i < 3; i++) {
  funcs[i] = (function () {
    var j = i;
    return function () {
      return j;
    };
  })();
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```

<details>
    <summary>정답</summary>
    0 1 2 <br>
    var j는 함수가 호출될때마다 새로 생성되고, 이 변수에 값을 할당했기에 그때의 값이 클로져로 유지됨
</details>

### 다음 코드의 Person의 스코프는?

```javascript
{
  console.log(Person);

  class Person {}
}
```

<details>
    <summary>정답</summary>
    해당 블록 레벨 스코프에 묶여있다.
</details>

---

## 클로드 문제들

### 다음 코드의 실행 결과를 예측하고 클로저가 어떻게 작동하는지 설명하세요

```javascript
function createCounter() {
  let count = 0;
  return function () {
    count += 1;
    return count;
  };
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1()); // ?
console.log(counter1()); // ?
console.log(counter2()); // ?
```

<details>
    <summary>정답</summary>
    1 2 1 <br>
    createCounter() 가 실행될때마다 새로운 count 변수가 생긴다. 여기에 클로저가 잡히기에, counter1과 counter2는 서로 다른 count 변수를 참조한다.
</details>

### 다음 코드에서 발생하는 문제를 찾고 수정하세요.

```javascript
const buttons = document.querySelectorAll("button");

for (var i = 0; i < buttons.length; i++) {
  buttons[i].addEventListener("click", function () {
    console.log("Button " + i + " clicked");
  });
}
```

<details>
    <summary>정답</summary>
    var i가 전역변수 취급되기에, 콜백함수로 등록되는 함수의 i 참조는 하나의 전역변수만을 참조하게 된다. <br>
    이를 let으로 바꾸면 해당 문제가 해결된다.
</details>

### 다음 함수의 출력 결과를 예측하고 클로저가 어떻게 사용되었는지 설명하세요.

```javascript
function makePowerFunction(power) {
  return function (base) {
    return Math.pow(base, power);
  };
}

const square = makePowerFunction(2);
const cube = makePowerFunction(3);

console.log(square(3)); // ?
console.log(cube(3)); // ?
```

<details>
    <summary>정답</summary>
    9 27<br>
    makePowerFunction() 로 만들어지는 함수는 해당 makePowerFunction가 호출시에 생성되는 인수(power) 에 클로저가 있다. 하지만 base의 경우 생성되는 함수의 인수를 참조하므로, 전달되는 인자의 값에 따라 달라진다.
</details>
