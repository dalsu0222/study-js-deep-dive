### 💡흥미로웠거나 새로 알게된 사실

- [클로저를 왜 쓰는가?](https://www.notion.so/24-1bc84330e99380a6abc0e31b03afb4b5?pvs=21)
- [JS에서의 접근지정자](https://www.notion.so/24-1bc84330e99380a6abc0e31b03afb4b5?pvs=21)
- [반복문에서의 클로저](https://www.notion.so/24-1bc84330e99380a6abc0e31b03afb4b5?pvs=21)

---

## 24.1 렉시컬 스코프

- 함수를 **어디에 정의**했는지에 따라 **상위 스코프를 결정**하는 것
- 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 따라 상위 스코프에 대한 참조가 결정되는 것
- 어디서 호출했는지는 영향을 주지 않음( this 바인딩이랑 헷갈리지 말자! )
- 스코프의 실체 → 렉시컬 환경. 
‘외부 렉시컬 환경에 대한 참조’에서 상위 렉시컬 환경(스코프)와 연결됨
참조값을 결정한다는 개념

## 24.2 함수 객체의 내부 슬롯 [[Environment]]

![image](https://github.com/user-attachments/assets/d50a16e0-3913-45d4-8302-dc7402c0c78b)


- 함수 객체 배수 슬롯 [[Environment]]에 저장되는 값 : 외부 렉시컬 환경에 대한 참조가 할당됨
- 함수 코드 평가 순서
    1. 함수 실행 컨텍스트 생성
    2. 함수 렉시컬 환경 생성
        
        2.1. 함수 환경 레코드 생성
        
        2.2. this 바인딩
        
        2.3. 외부 렉시컬 환경에 대한 참조 결정
        

## 24.3 클로저와 렉시컬 환경

- 클로저
    - 중첩함수, 외부함수보다 **중첩함수가 더 오래 유지**되는 경우 중첩함수는 이미 생명주기가 종료된 외부 함수의 변수를 참조할 수 있음
    - 이미 생명 주기가 종료 = 함수의 실행 컨텍스트가 제거되었다
- 상위 스코프의 어떤 식별자도 참조하지 않는다.
    
    →  즉, `bar` 내부에서 `foo`의 변수를 전혀 사용하지 않는다는 뜻.
    
    보통 중첩 함수는 외부 함수의 변수를 참조하면 클로저(Closure)를 형성하지만, 이 경우에는 그런 참조가 없다는 의미임.
    
- 클로저를 생성하지 않는다 = 내부 함수가 외부 변수를 전혀 참조하지 않는다.
    
    ```jsx
    function foo(){
    	const x = 1;
    	const y = 2;
    	
    	function bar(){ // -> 클로저 X
    		const z = 3;
    		
    		console.log(z);
    	}
    	bar();
    }
    ```
    
- 클로저이지만 클로저의 본질에 부합하지 않는 경우
    
    상위 스코프(예제에서는 외부함수)의 식별자를 참조하고 있으면 클로저임
    
    그렇지만 중첩함수(bar)가 반환되지 않는 경우, 외부 함수보다 일찍 소멸되기 때문에, 생명주기가 종료된 외부 함수의 식별자를 참조할 수 있다는 클로저의 본질에 부합하지 않음
    
    ```jsx
    function foo(){
    	const x = 1;
    	
    	function bar(){ // -> 곧바로 소멸, 클로저 기준에 미달
    		console.log(x);
    	}
    	bar();
    }
    ```
    
- 클로저인 경우
    
    중첩함수 bar → 외부 함수보다 더 오래 유지, 상위 스코프의 식별자를 참조하고 있으므로 클로저
    
    모던 브라우저의 경우, 최적화 존재. 메모리 걱정 크게 안해도 됨.
    
    ```jsx
    function foo(){
    	const x = 1; // 모던 브라우저의 경우, 최적화로 x만 클로저로 존재
    	const y = 2;
    	
    	function bar(){ // -> 곧바로 소멸, 클로저 기준에 미달
    		console.log(x);
    	}
    	return bar;
    }
    
    const bar = foo();
    bar();
    ```
    
- 헷갈리는점 → Q) 클로저를 생성하지 않는다는 말이, 외부 함수가 종료되면 내부 함수도 같이 종료된다?
    
    A) NO!!
    
    클로저가 없다고 해서 내부 함수가 무조건 사라지는 것은 아니고, **참조 여부**에 따라 달라진다.
    
    - 내부 함수가 **반환되거나 참조되면**, 클로저를 생성하지 않아도 계속 유지될 수 있음.
    - 내부 함수가 **어디에서도 참조되지 않으면**, 외부 함수가 종료될 때 같이 사라짐.
    - **클로저를 형성하면**, 외부 함수의 변수를 계속 유지하며 내부 함수도 사라지지 않음.

그래서 결론은.. 클로저란?

- 중첩 함수가 **상위 스코프의 식별자를 참조**하고 있고
- 중첩 함수가 **외부 함수보다 더 오래 유지되는 경우**에 한정하는 것이 일반적임

클로저가 왜 클로저인가

- 자유 변수 = 클로저에 의해 참조되는 상위 스코프의 변수
- 함수가 자유 변수에 닫혀있다는 뜻 = 자유 변수에 묶여있는 함수

## 24.4 클로저의 활용

- 클로저를 왜(Why) 사용하는가
    - 상태를 안전하게 변경하고 유지하기 위해 사용
    - 상태 은닉, 특정함수에게만 상태 변경 허용
    
    ```jsx
    let num = 0;
    
    const increase = function(){
    	return ++num;
    }
    console.log(increase()); // 1
    ```
    
    호출된 횟수(num) → 안전하게 변경하고 유지해야 할 상태
    
    근데 지금 num 변수는 전역변수라, 언제든지 변경될 가능성이 있음.
    
    → increase만이 num 변수를 참조하게 해보자
    
    → num변수를 increase 함수의 지역변수로 활용하여 의도치 않은 상태변경을 막아보자
    
    ```jsx
    const increase = function(){
    	let num = 0;
    	return ++num;
    }
    
    console.log(increase()); // 1
    console.log(increase()); // 1
    ```
    
    이제 외부에서 num 접근은 불가능.
    
    그렇지만 increase 함수가 호출될 때마다 지역변수 num이 다시 초기화되어서 언제나 1이 출력됨…
    
    → 이전상태 유지가 필요하다
    
    → 클로저를 사용해보자
    
    ```jsx
    const increase = (function (){
    		let num = 0;
    		// 클로저
    		return function(){
    			return ++num;
    		}
    	}());
    	console.log(increase()); // 1
    	console.log(increase()); // 2
    ```
    
    increase에 할당된 함수 → 상위스코프인 즉시실행함수 변수(num)가 포함된 렉시컬 환경을 기억하고 있는 클로저.
    
    즉시실행함수(가장 바깥)는 소멸되더라도, 렉시컬 환경은 기억하고 있으므로 반환함수에서는 이를 기억하고 있음. + **은닉 효과**
    
    즉시실행함수(가장 바깥)는 1번만 실행되므로 **매번 초기화가 일어나는 불상사 X**
    

다시 복습

- 클로저를 왜(Why) 사용하는가
    - 상태를 안전하게 변경하고 유지하기 위해 사용
    - 상태 은닉, 특정함수에게만 상태 변경 허용

만약에 감소시키는 함수(decrease())도 만들고 싶다면?

- return 값에 객체 리터럴을 반환하도록하고, 그 객체에 함수 메서드들을 ,로 구분하여 넣음(객체리터럴에 때려넣기)

함수를 인수로 전달받고 함수를 반환하는 고차 함수 형태의 클로저도 가능

독립된 렉시컬 환경 만들기 → p.408 그림

## 24.5 캡슐화와 정보 은닉

- 캡슐화?
    - 프로퍼티와 메서드를 하나로 묶는 것
    - 특정 프로퍼티와 메서드를 감출 목적(은닉)으로 사용하기도 함
- 은닉의 효과
    - 정보 보호. 적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방지
    - 결합도 낮추기. 객체간의 상호의존성 낮추기
- JS는 접근 제한자(public, private, protected 등..)를 제공하지 않음
    - 기본적으로 객체의 모든 프로퍼티와 메서드는 public!
- 기본적으로 생성자 함수안의 지역변수는 외부에서 참조하거나 변경할 수 없음.
    
    → private
    
- 근데 private 흉내내는것 마저도, 프로토타입 메서드로 인해 망가뜨려질 수 있음
- JS는 정보 은닉을 완전하게 지원 X..

## 24.6 자주 발생하는 실수

클로저 사용할때 자주 발생하는 실수들.

- 수정 전
    
    ```jsx
    var funcs = [];
    
    for(var i=0 ; i<3 ; i++){
    	funcs[i] = function(){ return i; };
    }
    
    for(var j=0 ; j<funcs.length ; j++){
    	console.log(funcs[j]);
    }
    ```
    
    → 결과는 ? 3
    
    서로가 다른 i값을 기억하는 것이 아님! 1,2,3 순차대로 반환하지 않음. 
    
    i는 전역변수(var)이기 때문에 , 모든 함수가 `i`의 최종 값(3)을 참조하고 있기 때문
    `funcs[i]`에 저장되는 함수는 **i의 현재 값을 복사하는 것이 아니라, i를 참조하는 함수.**
    
    `for` 루프가 끝나면 `i`는 `3`이 되고, **모든 함수가 이 `i`를 참조하고 있으므로** 실행할 때마다 `3`이 반환됨.
    
- 수정 후
    
    ```jsx
    var funcs = [];
    
    for(var i=0 ; i<3 ; i++){
    	funcs[i] = (function(id){ // 1
    	 return function(){
    			 return id;
    		 }; 
    	 }(i));
    }
    
    for(var j=0 ; j<funcs.length ; j++){
    	console.log(funcs[j]);
    }
    ```
    
    - 즉시실행함수로 감싸고, return값에 변수를 반환하는 함수 지정
    - i를 인수로 전달받고, 중첩함수를 반환하고 종료
        
        → 즉시실행함수의 매개변후 id 는 즉시실행함수만의 렉시컬 환경에서 기억됨. 이때의 즉시실행함수는 일종의 클로저
        
    - 근데 사실 var 대신 let 사용하면 됨… → Why? let은 반복문안에서 반복실행되어도 for문 코드블록마다의 새로운 렉시컬 환경이 생성되기 때문.
- 그림 궁금한 점 → 415p, let을 사용한 반복문에서의 렉시컬환경 참조
