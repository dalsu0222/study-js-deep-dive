### 💡흥미로웠거나 새로 알게된 사실

- [클래스와 생성자 함수의 유사점과 차이점](https://www.notion.so/25-1c384330e9938032931eda55f921dbc2?pvs=21)
- [클래스도 호이스팅이 일어난다.](https://www.notion.so/25-1c384330e9938032931eda55f921dbc2?pvs=21)

---

## 25.1 클래스는 프로토타입의 문법적 설탕인가?

- 클래스가 없어도, JS에서는 생성자 함수와 프로토타입을 통해 객체지향 언어의 상속 구현 가능
- 클래스와 생성자 함수 모두 프로토타입 기반의 인스턴스 생성 O
    
    But 완전하게 동일하지는 않음.
    
- 클래스는 생성자 함수보다 **엄격함**. **추가적인 기능** 제공.
    1. 클래스를 new 연산자 없이 호출하면 어러가 발생한다. 하지만 생성자 함수를 new 연산자 없이 호출하면 일반 참수로서 호출된다.
    2. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 하지만 생성자 함수는 extends와 super 키워드를 지원하지 않는다.
    3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.
    4. 클래스 내의 모든 코드에는 임묵적으로 strict mode가 지정되어 실행되며 strict mode를 해제할 수없 다. 하지만 생성자 함수는 암묵적으로 strict mode가 지정되지 않는다.
    5. 클래스의 constructor, 프로트타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 같이 false다. 다시 말해, 열거되지 않는다.
- **클래스**를 **새로운 객체 생성 메커니즘**으로 보는 것이 더 합당

## 25.2 클래스 정의

- class 키워드 및 파스칼 케이스 사용
    
    ```jsx
    class Person{}
    ```
    
- 표현식으로도 가능, 익명 가능
    
    ```jsx
    const Person = class {};
    const Person = class MyClass {};
    ```
    
- 클래스도 일종의 일급객체 → 값처럼 활용 가능
- 클래스 몸체에서 정의할 수 있는 메서드
    - constructor(생성자)
    - 프로토타입 메서드(static 키워드 안붙은 그냥 일반 메서드)
    - 정적 메서드(함수이름 앞에 static 키워드 붙음)

## 25.3 클래스 호이스팅

- 클래스를 typeof로 타입 체크하면 ? → 함수로 평가됨( function 출력)
    
    이말은 즉슨…
    
    클래스 선언문으로 정의한 클래스는, 함수 선언문과 같이 평가 과정(런타임) 이전에 먼저 평가가 되어 **함수 객체가 생성**된다는 뜻. → 생성되는 함수 객체? **Constructor**!
    
- 프로토타입 - 생성자 는 pair이므로, 프로토타입도 생성됨(복습 19.5절)
- 다만 클래스 정의 이전에 참조 불가능
- 클래스 선언문은 마치 호이스팅이 발생하지 않는 것처럼 보이나 그렇지 않음.
    - 클래스 선언문도 호이스팅이 발생한다.
    
    ```jsx
    const Person = '';
    {
    	// 호이스팅이 발생하지 않는다면 ''이 출력되어야 함
    	console.log(Person);
    	// ReferenceError : Cannot access 'Person' before initialization
    	
    	class Person {} // 클래스 선언
    }
    ```
    
    단 let, const 키워드처럼 호이스팅이 됨.
    
    → 선언 이전에 일시적 사각지대(TDZ)에 놓이므로 호이스팅이 발생하지 않는 것처럼 보이는 것.
    
    → 클래스도 호이스팅되지만 TDZ에 놓이므로 **초기화 전 접근하면 에러 발생**
    

## 25.4 인스턴스 생성

- 클래스의 인스턴스 생성하기
    - 반드시 new 연산자와 함께.. → 우리가 알던 방식
    - 사실 함수는 new 연산자 사용 여부에 따라 일반 함수로 호출되거나 인스턴스 생성을 위한 생성자 함수로 호출됨.
        - `new` 없이 호출하면 그냥 일반 함수처럼 실행됨
        - `new`를 붙이면 생성자 함수가 되어 새로운 객체를 만듦
- 아까 25.2 클래스 정의에서…
    
    ```jsx
    //const Person = class {};
    const Person = class MyClass {};
    
    const me = new Person();
    console.log(MyClass); // not defined error. 이름이 아닌 인스턴스로 접근해야함
    ```
    
    기명 클래스 표현식을 사용하는 경우 주의할 점.
    
    → 이름이 아닌 인스턴스로 접근해야함. 클래스 표현식의 이름 No. 담겨진 변수를 활용해야함.
